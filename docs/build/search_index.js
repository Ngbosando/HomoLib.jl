var documenterSearchIndex = {"docs":
[{"location":"generated/sensitivity_analysis/","page":"Numerical Analysis","title":"Numerical Analysis","text":"#' #'Finite Element Analysis of Composite Materials\n#'\n#' ##'Introduction\n#'\n#' This document presents a numerical analysis to determine the effective mechanical\n#' properties of composite materials. We use the Finite Element Method (FEM)\n#' to homogenize a Representative Volume Element (RVE) containing inclusions.\n#' The analysis compares a standard elastic model with a model that accounts for\n#' contact at the material interfaces.\n#'\n#' We perform two main studies:\n#' 1. **Convergence Study:** To determine how many random realizations are\n#'    needed to obtain stable statistical results.\n#' 2. **Sensitivity Analysis:** To observe the evolution of the effective stiffness\n#'    as a function of the inclusion volume fraction.\n#'\n#' The results are compared against the theoretical Voigt and Hashin-Shtrikman bounds.\n#'\n#'--------------------------------------------------------------------------------\n#' Imports and Configuration\n#'--------------------------------------------------------------------------------\nusing Revise\nusing HomoLib\nusing CairoMakie\nusing LinearAlgebra\nusing Statistics\nusing Printf\n#'\n#'--------------------------------------------------------------------------------\n#'Data Structures\n#'--------------------------------------------------------------------------------\nmutable struct MeshData\n    nodes::Matrix{Float64}\n    elements::Matrix{Int}\n    type_elem::Vector{Int}\n    boundary::Vector{Int}\n    boundary_inclusion::Vector{Int}\n    master::Vector{Int}\n    slave::Vector{Int}\nend\n#'\nmutable struct ElemData\n    type::Symbol\n    int_order::Int\n    order::Int\nend\n#'\n#'--------------------------------------------------------------------------------\n#'Core Analysis Functions","category":"page"},{"location":"generated/sensitivity_analysis/","page":"Numerical Analysis","title":"Numerical Analysis","text":"#'\nfunction setup_mesh(; width, height, volume_fraction,\n                      n_inclusions, elem_data::ElemData,\n                      node_divisions, shape, output_file, voids, rdn, show_gui, to_rotate)\n\n    ind_G, ind_D, ind_B, ind_H, ind_C,\n    elements, N_x, N_y, type_elem, _, _ =\n        generate_transfinite_plate_with_inclusions(\n            width, height, volume_fraction,\n            output_file, shape, n_inclusions,\n            elem_data.type, elem_data.order,\n            node_divisions[1], node_divisions[2];\n            voids=voids,\n            show_gui=show_gui,\n            rdn=rdn,\n            to_rotate=to_rotate\n        )\n\n    nodes = hcat(N_x, N_y)\n    boundary = unique(sort(vcat(ind_G, ind_D, ind_B, ind_H)))\n    master = vcat(ind_G, ind_B)\n    slave = vcat(ind_D, ind_H)\n\n    MeshData(nodes, elements, type_elem, boundary, ind_C, master, slave)\nend\n#'\nfunction run_standard_elastic_analysis(mesh::MeshData, elem_data::ElemData, E_matrix, ν_matrix, E_inclusion, ν_inclusion)\n    material_matrix = ElasticMaterial(2, E=E_matrix, ν=ν_matrix)\n    material_inclusion = ElasticMaterial(2, E=E_inclusion, ν=ν_inclusion)\n\n    geometric_data = precompute_geometric_data(\n        elem_data.type, elem_data.int_order, material_matrix.dim,\n        mesh.elements, mesh.nodes, material_matrix\n    )\n\n    K_assembly = assemble_KMF(\n        mesh.elements, mesh.nodes,\n        [material_matrix, material_inclusion],\n        material_matrix.dim, mesh.type_elem, geometric_data\n    )\n    K_matrix = K_assembly.K\n\n    bc1 = PeriodicHomogenizationBC([1.0 0.0; 0.0 0.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])\n    bc2 = PeriodicHomogenizationBC([0.0 0.0; 0.0 1.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])\n    bc3 = PeriodicHomogenizationBC([0.0 1/2; 1/2 0.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])\n\n    F_global = zeros(size(K_matrix, 1))\n    U_initial = zeros(size(K_matrix, 1))\n\n    U1 = solve!(K_matrix, F_global, U_initial, [bc1])\n    U2 = solve!(K_matrix, F_global, U_initial, [bc2])\n    U3 = solve!(K_matrix, F_global, U_initial, [bc3])\n\n    solver_results = (U = (U1, U2, U3),)\n\n    effective_tensor, _ = compute_effective_property(\n        [material_matrix, material_inclusion], mesh.elements, mesh.type_elem,\n        solver_results, material_matrix.dim, geometric_data\n    )\n\n    return effective_tensor.C\nend\n#'\n#'\nfunction run_contact_elastic_analysis(mesh::MeshData, elem_data::ElemData, E_matrix, ν_matrix, E_inclusion, ν_inclusion)\n    material_matrix = ElasticMaterial(2, E=E_matrix, ν=ν_matrix)\n    material_inclusion = ElasticMaterial(2, E=E_matrix, ν=ν_matrix)\n    material_inclusion.properties[:cracks] = true\n\n    geometric_data = precompute_geometric_data(\n        elem_data.type, elem_data.int_order, material_matrix.dim,\n        mesh.elements, mesh.nodes, material_matrix\n    )\n\n    K_assembly = assemble_KMF(\n        mesh.elements, mesh.nodes,\n        [material_matrix, ElasticMaterial(2, E=E_inclusion, ν=ν_inclusion)],\n        material_matrix.dim, mesh.type_elem, geometric_data\n    )\n    K_matrix = K_assembly.K\n\n    bc1 = PeriodicHomogenizationBC([1.0 0.0; 0.0 0.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])\n    bc2 = PeriodicHomogenizationBC([0.0 0.0; 0.0 1.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])\n    bc3 = PeriodicHomogenizationBC([0.0 1/2; 1/2 0.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])\n\n    F_global = zeros(size(K_matrix, 1))\n    U_initial = zeros(size(K_matrix, 1))\n\n    U1 = solve!(K_matrix, F_global, U_initial, [bc1])\n    U2 = solve!(K_matrix, F_global, U_initial, [bc2])\n    U3 = solve!(K_matrix, F_global, U_initial, [bc3])\n\n    solver_results = (U = (U1, U2, U3),)\n\n    effective_tensor, _ = compute_effective_property(\n        [material_matrix, material_inclusion], mesh.elements, mesh.type_elem,\n        solver_results, material_matrix.dim, geometric_data\n    )\n\n    return effective_tensor.C\nend\n#'\nfunction compute_effective_C(\n    volume_fraction::Float64, n_inclusions::Int, element_order::Int, shape::Symbol, element_type::Symbol,\n    node_div_inc::Int, node_div_mat::Int; analysis_type::Symbol, material_props)\n\n    is_tri = startswith(string(element_type), \"Tri\")\n    int_order = is_tri ? element_order : element_order * 2\n    elem_data = ElemData(element_type, int_order, element_order)\n\n    mesh = setup_mesh(\n        width=1.0, height=1.0, volume_fraction=volume_fraction, n_inclusions=n_inclusions,\n        elem_data=elem_data, node_divisions=(node_div_inc, node_div_mat), shape=shape,\n        output_file=\"RVE.msh\", voids=false, rdn=true, show_gui=false, to_rotate=true\n    )\n\n    if analysis_type == :standard\n        return run_standard_elastic_analysis(mesh, elem_data, material_props...)\n    elseif analysis_type == :contact\n        return run_contact_elastic_analysis(mesh, elem_data, material_props...)\n    else\n        error(\"Unsupported analysis_type: $analysis_type\")\n    end\nend\n#'\nfunction get_mean_effective_C(\n    n_realizations::Int, volume_fraction::Float64, n_inclusions::Int, element_order::Int,\n    shape::Symbol, element_type::Symbol, node_div_inc::Int, node_div_mat::Int; analysis_type::Symbol, material_props)\n\n    C_tensors = Vector{Matrix{Float64}}(undef, n_realizations)\n    for i in 1:n_realizations\n        C_tensors[i] = compute_effective_C(\n            volume_fraction, n_inclusions, element_order, shape, element_type,\n            node_div_inc, node_div_mat; analysis_type=analysis_type, material_props=material_props\n        )\n    end\n\n    mean_C_tensor = sum(C_tensors) / n_realizations\n\n    stds = [\n        std([c[1, 1] for c in C_tensors]),\n        std([c[2, 2] for c in C_tensors]),\n        std([c[1, 2] for c in C_tensors]),\n        std([c[3, 3] for c in C_tensors])\n    ]\n\n    return mean_C_tensor, stds\nend\n#'\nfunction run_sensitivity_analysis(\n    n_samples::Int, n_realizations::Int, n_inclusions::Int, element_order::Int, shape::Symbol,\n    element_type::Symbol, node_div_inc::Int, node_div_mat::Int;\n    min_vf::Float64, max_vf::Float64, analysis_type::Symbol, material_props)\n\n    vf_values = range(min_vf, max_vf, length=n_samples)\n    results = Vector{NamedTuple{(:vf, :mean_C, :stds_C), Tuple{Float64, Matrix{Float64}, Vector{Float64}}}}(undef, n_samples)\n\n    println(\"Starting Sensitivity Analysis for $(analysis_type)...\")\n    for i in 1:n_samples\n        vf = vf_values[i]\n        mean_C, stds_C = get_mean_effective_C(\n            n_realizations, vf, n_inclusions, element_order,\n            shape, element_type, node_div_inc, node_div_mat;\n            analysis_type=analysis_type, material_props=material_props\n        )\n        results[i] = (vf=vf, mean_C=mean_C, stds_C=stds_C)\n    end\n\n    sort!(results, by = x -> x.vf)\n\n    #'Convert to the format expected by the plotting functions\n    vf_sorted = [r.vf for r in results]\n    means_sorted = (\n        c1111=[r.mean_C[1,1] for r in results],\n        c2222=[r.mean_C[2,2] for r in results],\n        c1122=[r.mean_C[1,2] for r in results],\n        c1212=[r.mean_C[3,3] for r in results]\n    )\n    stds_sorted = (\n        c1111=[r.stds_C[1] for r in results],\n        c2222=[r.stds_C[2] for r in results],\n        c1122=[r.stds_C[3] for r in results],\n        c1212=[r.stds_C[4] for r in results]\n    )\n\n    return vf_sorted, means_sorted, stds_sorted\nend\n#'\nfunction run_convergence_study(\n    max_realizations::Int, n_steps::Int, volume_fraction::Float64,\n    n_inclusions::Int, element_order::Int, shape::Symbol, element_type::Symbol,\n    node_div_inc::Int, node_div_mat::Int; analysis_type::Symbol, material_props)\n\n    all_C_tensors = [compute_effective_C(\n        volume_fraction, n_inclusions, element_order, shape, element_type,\n        node_div_inc, node_div_mat; analysis_type=analysis_type, material_props=material_props\n    ) for _ in 1:max_realizations]\n\n    step_size = floor(Int, max_realizations / n_steps)\n    if step_size == 0; step_size = 1; end\n    realization_counts = unique(vcat(collect(1:step_size:max_realizations), max_realizations))\n\n    means = [(\n        c1111=mean([c[1,1] for c in @view all_C_tensors[1:n]]),\n        c2222=mean([c[2,2] for c in @view all_C_tensors[1:n]]),\n        c1122=mean([c[1,2] for c in @view all_C_tensors[1:n]]),\n        c1212=mean([c[3,3] for c in @view all_C_tensors[1:n]])\n    ) for n in realization_counts]\n\n    stds = [(\n        c1111= n > 1 ? std([c[1,1] for c in @view all_C_tensors[1:n]]) : 0.0,\n        c2222= n > 1 ? std([c[2,2] for c in @view all_C_tensors[1:n]]) : 0.0,\n        c1122= n > 1 ? std([c[1,2] for c in @view all_C_tensors[1:n]]) : 0.0,\n        c1212= n > 1 ? std([c[3,3] for c in @view all_C_tensors[1:n]]) : 0.0\n    ) for n in realization_counts]\n\n    return realization_counts, means, stds\nend\n#'\nfunction compute_CI(std_devs, n_realizations::Int; confidence::Float64=0.95)\n    z_scores = Dict(0.90=>1.645, 0.95=>1.960, 0.99=>2.576)\n    z = get(z_scores, confidence, 1.960)\n    return z .* std_devs ./ sqrt(n_realizations)\nend\n#'\nfunction plot_convergence_study(\n    realizations, means_std, stds_std, means_contact, stds_contact)\n\n    fig = Figure(size=(1200, 1000), fontsize=18)\n    ga = fig[1, 1] = GridLayout()\n    gb = fig[2, 1] = GridLayout()\n    Label(ga[1, 1:2], \"Convergence of Mean Stiffness Components\", fontsize=24, font=:bold, padding=(0,0,20,0))\n    Label(gb[1, 1:2], \"Convergence of Standard Deviation\", fontsize=24, font=:bold, padding=(0,0,20,0))\n\n    axes_mean = [Axis(ga[2, c], xlabel=\"Number of Realizations\", ylabel=\"Mean C (GPa)\") for c in 1:2]\n    append!(axes_mean, [Axis(ga[3, c], xlabel=\"Number of Realizations\", ylabel=\"Mean C (GPa)\") for c in 1:2])\n    axes_std = [Axis(gb[2, c], xlabel=\"Number of Realizations\", ylabel=\"Std Dev (GPa)\") for c in 1:2]\n    append!(axes_std, [Axis(gb[3, c], xlabel=\"Number of Realizations\", ylabel=\"Std Dev (GPa)\") for c in 1:2])\n\n    components = [:c1111, :c2222, :c1122, :c1212]\n    titles = [\"C₁₁₁₁\", \"C₂₂₂₂\", \"C₁₁₂₂\", \"C₁₂₁₂\"]\n\n    for i in 1:4\n        ax_m, ax_s = axes_mean[i], axes_std[i]\n        ax_m.title = titles[i]\n        ax_s.title = titles[i]\n\n        lines!(ax_m, realizations, [m[i] for m in means_std], color=:blue, label=\"Standard\")\n        scatter!(ax_m, realizations, [m[i] for m in means_std], color=:blue)\n        lines!(ax_s, realizations, [s[i] for s in stds_std], color=:blue, label=\"Standard\")\n        scatter!(ax_s, realizations, [s[i] for s in stds_std], color=:blue)\n\n        lines!(ax_m, realizations, [m[i] for m in means_contact], color=:red, label=\"Contact\")\n        scatter!(ax_m, realizations, [m[i] for m in means_contact], color=:red, marker=:utriangle)\n        lines!(ax_s, realizations, [s[i] for s in stds_contact], color=:red, label=\"Contact\")\n        scatter!(ax_s, realizations, [s[i] for s in stds_contact], color=:red, marker=:utriangle)\n    end\n\n    axislegend(axes_mean[1], position=:rt)\n    return fig\nend\n#'\nfunction compute_theoretical_bounds(vf_values, C_matrix)\n    #'--- helpers ---------------------------------------------------------\n    #'extract effective bulk (κ) and shear (μ) from your 2D C-matrix convention\n    #'NOTE: this assumes C_matrix[1,1] == C1111 and C_matrix[3,3] == C1212 (shear)\n    κ_m = C_matrix[1,1] - (4.0/3.0)*C_matrix[3,3]\n    μ_m = C_matrix[3,3]\n\n    #'Extract ν_matrix for Mori-Tanaka\n    ν_matrix = (3*κ_m - 2*μ_m) / (2*(3*κ_m + μ_m))\n\n    #'phase 2 = inclusion / void; user may pass near-zero stiffness or proper C for inclusions\n    #'we'll accept that inclusions are zero-stiffness: κ_i = 0, μ_i = 0 when necessary\n    κ_i = 0.0\n    μ_i = 0.0\n\n    #'safe reciprocal helper\n    safe_inv(x; tol=1e-12) = abs(x) < tol ? sign(x)/tol : 1.0/x\n\n    #'Voigt & Reuss for bulk and shear\n    function voigt_reuss(κ1, μ1, κ2, μ2, f2)\n        f1 = 1.0 - f2\n        κV = f1*κ1 + f2*κ2\n        μV = f1*μ1 + f2*μ2\n        invκR = (f1/κ1) + (f2/κ2)\n        invμR = (f1/μ1) + (f2/μ2)\n        κR = invκR == 0.0 ? 0.0 : 1.0 / invκR\n        μR = invμR == 0.0 ? 0.0 : 1.0 / invμR\n        return κV, μV, κR, μR\n    end\n\n    #'robust Hashin-Shtrikman (returns κ_lower, μ_lower, κ_upper, μ_upper)\n    function hashin_shtrikman_safe(κ1, μ1, κ2, μ2, f2; tol=1e-12)\n        f1 = 1.0 - f2\n\n        Δκ = κ2 - κ1\n        termK1 = 3*κ1 + 4*μ1\n        denom_a = safe_inv(Δκ; tol=tol) + 3*f1/termK1\n        a = κ1 + (abs(denom_a) < tol ? 0.0 : f2 / denom_a)\n\n        Δκ_b = κ1 - κ2\n        termK2 = 3*κ2 + 4*μ2\n        denom_b = safe_inv(Δκ_b; tol=tol) + 3*f2/termK2\n        b = κ2 + (abs(denom_b) < tol ? 0.0 : f1 / denom_b)\n\n        Δμ = μ2 - μ1\n        safe_mu = x -> abs(x) < tol ? tol * sign(x) : x\n\n        denom_alpha = safe_inv(Δμ; tol=tol) + 6*f1*(κ1 + 2*μ1) / (5*safe_mu(μ1)*(3*κ1 + 4*μ1))\n        α = μ1 + (abs(denom_alpha) < tol ? 0.0 : f2 / denom_alpha)\n\n        denom_beta = safe_inv(-Δμ; tol=tol) + 6*f2*(κ2 + 2*μ2) / (5*safe_mu(μ2)*(3*κ2 + 4*μ2))\n        β = μ2 + (abs(denom_beta) < tol ? 0.0 : f1 / denom_beta)\n\n        κ_lower, κ_upper = min(a,b), max(a,b)\n        μ_lower, μ_upper = min(α,β), max(α,β)\n        return κ_lower, μ_lower, κ_upper, μ_upper\n    end\n\n    #'map (κ, μ) -> components used in plotting\n    C1111 = (κ, μ) -> κ + (4.0/3.0)*μ\n    C1122 = (κ, μ) -> κ - (2.0/3.0)*μ\n    C1212 = (κ, μ) -> μ\n\n    #'--- allocate outputs ------------------------------------------------\n    vf = collect(vf_values)\n    n = length(vf)\n    voigt = Dict(k => zeros(n) for k in (:c1111,:c1122,:c1212))\n    reuss = Dict(k => zeros(n) for k in (:c1111,:c1122,:c1212))\n    hs_low = Dict(k => zeros(n) for k in (:c1111,:c1122,:c1212))\n    hs_up  = Dict(k => zeros(n) for k in (:c1111,:c1122,:c1212))\n    mt = Dict(k => zeros(n) for k in (:c1111,:c1122,:c1212))  #'ADDED: Mori-Tanaka\n\n    #'inclusion moduli (we assume voids; change if you have actual inclusion C)\n    κ2 = κ_i\n    μ2 = μ_i\n    κ1 = κ_m\n    μ1 = μ_m\n\n    for (i, f) in enumerate(vf)\n        κV, μV, κR, μR = voigt_reuss(κ1, μ1, κ2, μ2, f)\n        kll, mll, kuu, muu = hashin_shtrikman_safe(κ1, μ1, κ2, μ2, f)\n\n        #'ADDED: Mori-Tanaka for spherical voids\n        κ_mt = κ1 * (1 - f) / (1 + 3*(1-ν_matrix)/(2*(1-2*ν_matrix)) * f)\n        μ_mt = μ1 * (1 - f) / (1 + (15*(1-ν_matrix))/(7-5*ν_matrix) * f)\n\n        voigt[:c1111][i] = C1111(κV, μV)\n        voigt[:c1122][i] = C1122(κV, μV)\n        voigt[:c1212][i] = C1212(κV, μV)\n\n        reuss[:c1111][i] = C1111(κR, μR)\n        reuss[:c1122][i] = C1122(κR, μR)\n        reuss[:c1212][i] = C1212(κR, μR)\n\n        hs_low[:c1111][i] = C1111(kll, mll)\n        hs_low[:c1122][i] = C1122(kll, mll)\n        hs_low[:c1212][i] = C1212(kll, mll)\n\n        hs_up[:c1111][i] = C1111(kuu, muu)\n        hs_up[:c1122][i] = C1122(kuu, muu)\n        hs_up[:c1212][i] = C1212(kuu, muu)\n\n        #'ADDED: Mori-Tanaka values\n        mt[:c1111][i] = C1111(κ_mt, μ_mt)\n        mt[:c1122][i] = C1122(κ_mt, μ_mt)\n        mt[:c1212][i] = C1212(κ_mt, μ_mt)\n    end\n\n    return (voigt=voigt, reuss=reuss, hs_lower=hs_low, hs_upper=hs_up, mori_tanaka=mt)  #'ADDED: mori_tanaka\nend\n#'\nfunction get_matrix_C(E_matrix, ν_matrix; plane_stress=true)\n    if plane_stress\n        factor = E_matrix / (1 - ν_matrix^2)\n        C11 = factor\n        C12 = ν_matrix * factor\n        C33 = E_matrix / (2*(1 + ν_matrix))\n        return [C11 C12 0; C12 C11 0; 0 0 C33]\n    else\n        factor = E_matrix / ((1 + ν_matrix) * (1 - 2*ν_matrix))\n        C11 = factor * (1 - ν_matrix)\n        C12 = factor * ν_matrix\n        C33 = factor * (1 - 2*ν_matrix) / 2\n        return [C11 C12 0; C12 C11 0; 0 0 C33]\n    end\nend\n#'\nfunction plot_sensitivity_results(\n    vf_values, means_std, stds_std, means_contact, stds_contact, n_realizations,\n    C_matrix)\n\n    bounds = compute_theoretical_bounds(vf_values, C_matrix)\n\n    fig = Figure(size=(1200, 1000), fontsize=18)\n    Label(fig[1, 1:2], \"Sensitivity Analysis (N = $(n_realizations))\",\n          fontsize=24, font=:bold, padding=(0,0,20,0))\n\n    #'Create all axes explicitly\n    axes = [\n        Axis(fig[2, 1], xlabel=\"Volume Fraction (Porosity) ϕ\", ylabel=\"Effective Stiffness (GPa)\"),\n        Axis(fig[2, 2], xlabel=\"Volume Fraction (Porosity) ϕ\", ylabel=\"Effective Stiffness (GPa)\"),\n        Axis(fig[3, 1], xlabel=\"Volume Fraction (Porosity) ϕ\", ylabel=\"Effective Stiffness (GPa)\"),\n        Axis(fig[3, 2], xlabel=\"Volume Fraction (Porosity) ϕ\", ylabel=\"Effective Stiffness (GPa)\")\n    ]\n\n    components = [:c1111, :c2222, :c1122, :c1212]\n    titles = [\"C₁₁₁₁\", \"C₂₂₂₂\", \"C₁₁₂₂\", \"C₁₂₁₂\"]\n    bound_keys = [:c1111, :c1111, :c1122, :c1212]  #'Map plot components to bound components\n\n    for i in 1:4\n        ax = axes[i]\n        ax.title = titles[i]\n        comp_key = components[i]\n        bound_key = bound_keys[i]\n\n        ci_std = compute_CI(stds_std[comp_key], n_realizations)\n        ci_contact = compute_CI(stds_contact[comp_key], n_realizations)\n\n        #'Plot numerical results\n        scatter!(ax, vf_values, means_std[comp_key], marker=:circle, color=:blue)\n        errorbars!(ax, vf_values, means_std[comp_key], ci_std, color=:blue)\n\n        scatter!(ax, vf_values, means_contact[comp_key], marker=:utriangle, color=:red)\n        errorbars!(ax, vf_values, means_contact[comp_key], ci_contact, color=:red)\n\n        #'Add theoretical bounds\n        lines!(ax, vf_values, bounds.voigt[bound_key], color=:green, linestyle=:dash, linewidth=2)\n        lines!(ax, vf_values, bounds.hs_upper[bound_key], color=:purple, linestyle=:dash, linewidth=2)\n        lines!(ax, vf_values, bounds.hs_lower[bound_key], color=:orange, linestyle=:dash, linewidth=2)\n        lines!(ax, vf_values, bounds.mori_tanaka[bound_key], color=:brown, linestyle=:dash, linewidth=2)\n\n        #'For Reuss bound, only show if it's not too close to zero (for visualization)\n        if maximum(bounds.reuss[bound_key]) > 1e-3\n            lines!(ax, vf_values, bounds.reuss[bound_key], color=:gray, linestyle=:dash, linewidth=1, alpha=0.7)\n        end\n    end\n\n    #'Create comprehensive legend\n    elements = [\n        MarkerElement(marker=:circle, color=:blue, markersize=15),\n        LineElement(color=:blue, linestyle=:solid),\n        MarkerElement(marker=:utriangle, color=:red, markersize=15),\n        LineElement(color=:red, linestyle=:solid),\n        LineElement(color=:green, linestyle=:dash, linewidth=2),\n        LineElement(color=:purple, linestyle=:dash, linewidth=2),\n        LineElement(color=:orange, linestyle=:dash, linewidth=2),\n        LineElement(color=:brown, linestyle=:dash, linewidth=2),\n        LineElement(color=:gray, linestyle=:dash, linewidth=1, alpha=0.7)\n    ]\n\n    labels = [\n        \"Standard Mean\", \"Standard 95% CI\",\n        \"Contact Mean\", \"Contact 95% CI\",\n        \"Voigt Upper Bound\", \"HS Upper Bound\",\n        \"HS Lower Bound\", \"Mori-Tanaka\",\n        \"Reuss Lower Bound\"\n    ]\n\n    Legend(fig[4, 1:2], elements, labels,\n           orientation=:horizontal, tellwidth=false, tellheight=true,\n           framevisible=false, nbanks=3)\n\n    return fig\nend\n#'\nfunction plot_constitutive_law(vf_values, means_std, means_contact, target_vf::Float64)\n    #'Find the index closest to the target volume fraction\n    idx = argmin(abs.(vf_values .- target_vf))\n    vf_target = vf_values[idx]\n\n    #'Extract the constitutive tensors at the target volume fraction\n    C_std = means_std.c1111[idx], means_std.c2222[idx], means_std.c1122[idx], means_std.c1212[idx]\n    C_contact = means_contact.c1111[idx], means_contact.c2222[idx], means_contact.c1122[idx], means_contact.c1212[idx]\n\n    #'Convert to matrix format for compatibility\n    C_std_matrix = [C_std[1] C_std[3] 0; C_std[3] C_std[2] 0; 0 0 C_std[4]]\n    C_contact_matrix = [C_contact[1] C_contact[3] 0; C_contact[3] C_contact[2] 0; 0 0 C_contact[4]]\n\n    fig = Figure(size=(1200, 1000), fontsize=18)\n    Label(fig[1, 1:2], \"Effective Asymmetric Constitutive Law (ϕ = $(round(vf_target*100, digits=1))% Porosity)\",\n          fontsize=24, font=:bold, padding=(0,0,20,0))\n\n    #'Create all axes explicitly\n    axes = [\n        Axis(fig[2, 1]),\n        Axis(fig[2, 2]),\n        Axis(fig[3, 1]),\n        Axis(fig[3, 2])\n    ]\n\n    titles = [\n        \"σ₁₁ vs ε₁₁ (Uniaxial Loading)\", \"σ₂₂ vs ε₂₂ (Uniaxial Loading)\",\n        \"σ₁₂ vs 2ε₁₂ (Shear Loading)\", \"σ₂₂ vs ε₁₁ (Poisson Effect)\"\n    ]\n    xlabels = [\"Strain ε₁₁\", \"Strain ε₂₂\", \"Shear Strain 2ε₁₂\", \"Strain ε₁₁\"]\n    ylabels = [\"Stress σ₁₁ (GPa)\", \"Stress σ₂₂ (GPa)\", \"Stress σ₁₂ (GPa)\", \"Stress σ₂₂ (GPa)\"]\n\n    strain_range = -0.01:0.0002:0.01\n\n    #'C1111 plot\n    stress_std_11 = C_std_matrix[1, 1] .* strain_range\n    stress_contact_11 = [ε >= 0 ? C_contact_matrix[1, 1] * ε : C_std_matrix[1, 1] * ε for ε in strain_range]\n    lines!(axes[1], strain_range, stress_std_11, label=\"Standard\", color=:blue)\n    lines!(axes[1], strain_range, stress_contact_11, label=\"Contact\", color=:red)\n\n    #'C2222 plot\n    stress_std_22 = C_std_matrix[2, 2] .* strain_range\n    stress_contact_22 = [ε >= 0 ? C_contact_matrix[2, 2] * ε : C_std_matrix[2, 2] * ε for ε in strain_range]\n    lines!(axes[2], strain_range, stress_std_22, color=:blue)\n    lines!(axes[2], strain_range, stress_contact_22, color=:red)\n\n    #'C1212 (shear) plot\n    stress_std_12 = C_std_matrix[3, 3] .* strain_range\n    stress_contact_12 = [ε >= 0 ? C_contact_matrix[3, 3] * ε : C_std_matrix[3, 3] * ε for ε in strain_range]\n    lines!(axes[3], strain_range, stress_std_12, color=:blue)\n    lines!(axes[3], strain_range, stress_contact_12, color=:red)\n\n    #'C1122 (Poisson) plot\n    stress_std_1122 = C_std_matrix[1, 2] .* strain_range\n    stress_contact_1122 = [ε >= 0 ? C_contact_matrix[1, 2] * ε : C_std_matrix[1, 2] * ε for ε in strain_range]\n    lines!(axes[4], strain_range, stress_std_1122, color=:blue)\n    lines!(axes[4], strain_range, stress_contact_1122, color=:red)\n\n    for i in 1:4\n        axes[i].title = titles[i]\n        axes[i].xlabel = xlabels[i]\n        axes[i].ylabel = ylabels[i]\n        vlines!(axes[i], [0.0], color=:black, linestyle=:dash)\n        hlines!(axes[i], [0.0], color=:black, linestyle=:dash)\n    end\n\n    axislegend(axes[1], position=:lt)\n    return fig\nend\n#'\n#' ---\n#' ##'Analysis Execution\n#'\n#' We now define the simulation parameters and run the studies.\n#'\n#'\n#' Simulation Parameters\nn_realizations = 20\nn_samples = 5\nmax_conv_real = 50\nn_conv_steps = 10\n#'\n#'RVE Parameters\nvolume_fraction = 0.6 #'60% porosity for final plot\nn_inclusions = 10\nelement_order = 2\nshape = :circle\nelement_type = :Tri6\nnode_div_inc = 10\nnode_div_mat = 20\n#'\n#'Material Properties: Generic Composite with Soft Inclusions\n#'Units are in GPa.\nE_matrix, ν_matrix = 1.0, 0.3\nE_inclusion, ν_inclusion = 1e-6, 0.3\nmaterial_props = (E_matrix, ν_matrix, E_inclusion, ν_inclusion)\n#'\n#'\n#' ###'1. Convergence Study\n#'\n#' The convergence study is performed for a fixed inclusion volume fraction of 60%.\n#' We observe how the mean and standard deviation of the effective stiffness\n#' components stabilize as the number of geometric realizations increases.\n#'\n#'\nprintln(\"\\n Running Convergence Study \")\nrealization_counts, means_std_conv, stds_std_conv = run_convergence_study(\n    max_conv_real, n_conv_steps, volume_fraction, n_inclusions, element_order,\n    shape, element_type, node_div_inc, node_div_mat; analysis_type=:standard, material_props=material_props\n)\n_, means_contact_conv, stds_contact_conv = run_convergence_study(\n    max_conv_real, n_conv_steps, volume_fraction, n_inclusions, element_order,\n    shape, element_type, node_div_inc, node_div_mat; analysis_type=:contact, material_props=material_props\n)\nfig_conv = plot_convergence_study(realization_counts, means_std_conv, stds_std_conv, means_contact_conv, stds_contact_conv)\nsave(\"convergence_study.png\", fig_conv)\nfig_conv\n#'\n#'\n#' ###'2. Sensitivity Analysis\n#'\n#' The sensitivity analysis explores the impact of the volume fraction,\n#' varying from 10% to 70%, on the effective stiffness components.\n#' Each data point is the average of 20 realizations.\n#'\n#'\nprintln(\"\\n Running Sensitivity Analysis \")\nmin_vf, max_vf = 0.1, 0.70\n#'\nvf_values, means_std, stds_std = run_sensitivity_analysis(\n    n_samples, n_realizations, n_inclusions, element_order, shape, element_type,\n    node_div_inc, node_div_mat; min_vf=min_vf, max_vf=max_vf, analysis_type=:standard, material_props=material_props\n)\n_, means_contact, stds_contact = run_sensitivity_analysis(\n    n_samples, n_realizations, n_inclusions, element_order, shape, element_type,\n    node_div_inc, node_div_mat; min_vf=min_vf, max_vf=max_vf, analysis_type=:contact, material_props=material_props\n)\n#'\n#'Get matrix constitutive tensor for theoretical bounds\nC_matrix = get_matrix_C(E_matrix, ν_matrix, plane_stress=true)\n#'\n#'Plot with theoretical bounds including Mori-Tanaka\nfig_sens = plot_sensitivity_results(\n    vf_values, means_std, stds_std, means_contact, stds_contact, n_realizations,\n    C_matrix\n)\nsave(\"sensitivity_analysis.png\", fig_sens)\nfig_sens\n#'\n#'\n#' ###'3. Final Comparison and Conclusion\n#'\n#' Finally, we compare the effective constitutive law for both models\n#' at a fixed volume fraction of 60%, reusing the data computed during the sensitivity study.\n#'\n#'\nprintln(\"\\n Plotting Constitutive Law using Sensitivity Analysis Results\")\n#'\n#'Plot constitutive law using the averaged results from sensitivity analysis\ntarget_vf = 0.6  #'60% volume fraction\nfig_constitutive = plot_constitutive_law(vf_values, means_std, means_contact, target_vf)\nsave(\"constitutive_law_$(Int(target_vf*100))percent.png\", fig_constitutive)\nfig_constitutive\n#'\n#'\n#' The following table summarizes the final results.\n#'\n#'\n#'Also create summary table\nprintln(\"\\n --- Summary Results for ϕ = $(target_vf*100)% Volume Fraction ---\")\n#'\n#'Find the index closest to target porosity\nidx = argmin(abs.(vf_values .- target_vf))\nmean_C_std_at_target = [means_std.c1111[idx], means_std.c2222[idx], means_std.c1122[idx], means_std.c1212[idx]]\nmean_C_contact_at_target = [means_contact.c1111[idx], means_contact.c2222[idx], means_contact.c1122[idx], means_contact.c1212[idx]]\n#'\n@printf \"Component | Standard (GPa) | Contact (GPa) | Difference (%%)\\n\"\n@printf \"----------|----------------|---------------|----------------\\n\"\ncomps = [\"C₁₁₁₁\", \"C₂₂₂₂\", \"C₁₁₂₂\", \"C₁₂₁₂\"];\nfor i in 1:4\n    std_val = mean_C_std_at_target[i]\n    con_val = mean_C_contact_at_target[i]\n    diff = (con_val / std_val - 1) * 100\n    @printf \"%-9s | %14.4f | %13.4f | %13.2f\\n\" comps[i] std_val con_val diff\nend\n#'","category":"page"},{"location":"generated/sensitivity_analysis/","page":"Numerical Analysis","title":"Numerical Analysis","text":"","category":"page"},{"location":"generated/sensitivity_analysis/","page":"Numerical Analysis","title":"Numerical Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#FEM-Analysis-of-Composite-Materials","page":"Home","title":"FEM Analysis of Composite Materials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for this Finite Element analysis project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This site contains a detailed report, generated from a Julia script, that investigates the effective mechanical properties of composite materials with soft inclusions.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"```@contents Pages = [     \"index.md\",     \"generated/analysis.md\" ]","category":"page"}]
}
