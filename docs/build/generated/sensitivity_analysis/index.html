<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Analysis · FEM Analysis of Composites</title><meta name="title" content="Numerical Analysis · FEM Analysis of Composites"/><meta property="og:title" content="Numerical Analysis · FEM Analysis of Composites"/><meta property="twitter:title" content="Numerical Analysis · FEM Analysis of Composites"/><meta name="description" content="Documentation for FEM Analysis of Composites."/><meta property="og:description" content="Documentation for FEM Analysis of Composites."/><meta property="twitter:description" content="Documentation for FEM Analysis of Composites."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FEM Analysis of Composites</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li class="is-active"><a class="tocitem" href>Numerical Analysis</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/leycrimson/HomoLib.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/leycrimson/HomoLib.jl/blob/main/docs/src/sensitivity_analysis.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia hljs">#&#39; #&#39;Finite Element Analysis of Composite Materials
#&#39;
#&#39; ##&#39;Introduction
#&#39;
#&#39; This document presents a numerical analysis to determine the effective mechanical
#&#39; properties of composite materials. We use the Finite Element Method (FEM)
#&#39; to homogenize a Representative Volume Element (RVE) containing inclusions.
#&#39; The analysis compares a standard elastic model with a model that accounts for
#&#39; contact at the material interfaces.
#&#39;
#&#39; We perform two main studies:
#&#39; 1. **Convergence Study:** To determine how many random realizations are
#&#39;    needed to obtain stable statistical results.
#&#39; 2. **Sensitivity Analysis:** To observe the evolution of the effective stiffness
#&#39;    as a function of the inclusion volume fraction.
#&#39;
#&#39; The results are compared against the theoretical Voigt and Hashin-Shtrikman bounds.
#&#39;
#&#39;--------------------------------------------------------------------------------
#&#39; Imports and Configuration
#&#39;--------------------------------------------------------------------------------
using Revise
using HomoLib
using CairoMakie
using LinearAlgebra
using Statistics
using Printf
#&#39;
#&#39;--------------------------------------------------------------------------------
#&#39;Data Structures
#&#39;--------------------------------------------------------------------------------
mutable struct MeshData
    nodes::Matrix{Float64}
    elements::Matrix{Int}
    type_elem::Vector{Int}
    boundary::Vector{Int}
    boundary_inclusion::Vector{Int}
    master::Vector{Int}
    slave::Vector{Int}
end
#&#39;
mutable struct ElemData
    type::Symbol
    int_order::Int
    order::Int
end
#&#39;
#&#39;--------------------------------------------------------------------------------
#&#39;Core Analysis Functions</code></pre><pre><code class="language-julia hljs">#&#39;
function setup_mesh(; width, height, volume_fraction,
                      n_inclusions, elem_data::ElemData,
                      node_divisions, shape, output_file, voids, rdn, show_gui, to_rotate)

    ind_G, ind_D, ind_B, ind_H, ind_C,
    elements, N_x, N_y, type_elem, _, _ =
        generate_transfinite_plate_with_inclusions(
            width, height, volume_fraction,
            output_file, shape, n_inclusions,
            elem_data.type, elem_data.order,
            node_divisions[1], node_divisions[2];
            voids=voids,
            show_gui=show_gui,
            rdn=rdn,
            to_rotate=to_rotate
        )

    nodes = hcat(N_x, N_y)
    boundary = unique(sort(vcat(ind_G, ind_D, ind_B, ind_H)))
    master = vcat(ind_G, ind_B)
    slave = vcat(ind_D, ind_H)

    MeshData(nodes, elements, type_elem, boundary, ind_C, master, slave)
end
#&#39;
function run_standard_elastic_analysis(mesh::MeshData, elem_data::ElemData, E_matrix, ν_matrix, E_inclusion, ν_inclusion)
    material_matrix = ElasticMaterial(2, E=E_matrix, ν=ν_matrix)
    material_inclusion = ElasticMaterial(2, E=E_inclusion, ν=ν_inclusion)

    geometric_data = precompute_geometric_data(
        elem_data.type, elem_data.int_order, material_matrix.dim,
        mesh.elements, mesh.nodes, material_matrix
    )

    K_assembly = assemble_KMF(
        mesh.elements, mesh.nodes,
        [material_matrix, material_inclusion],
        material_matrix.dim, mesh.type_elem, geometric_data
    )
    K_matrix = K_assembly.K

    bc1 = PeriodicHomogenizationBC([1.0 0.0; 0.0 0.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])
    bc2 = PeriodicHomogenizationBC([0.0 0.0; 0.0 1.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])
    bc3 = PeriodicHomogenizationBC([0.0 1/2; 1/2 0.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])

    F_global = zeros(size(K_matrix, 1))
    U_initial = zeros(size(K_matrix, 1))

    U1 = solve!(K_matrix, F_global, U_initial, [bc1])
    U2 = solve!(K_matrix, F_global, U_initial, [bc2])
    U3 = solve!(K_matrix, F_global, U_initial, [bc3])

    solver_results = (U = (U1, U2, U3),)

    effective_tensor, _ = compute_effective_property(
        [material_matrix, material_inclusion], mesh.elements, mesh.type_elem,
        solver_results, material_matrix.dim, geometric_data
    )

    return effective_tensor.C
end
#&#39;
#&#39;
function run_contact_elastic_analysis(mesh::MeshData, elem_data::ElemData, E_matrix, ν_matrix, E_inclusion, ν_inclusion)
    material_matrix = ElasticMaterial(2, E=E_matrix, ν=ν_matrix)
    material_inclusion = ElasticMaterial(2, E=E_matrix, ν=ν_matrix)
    material_inclusion.properties[:cracks] = true

    geometric_data = precompute_geometric_data(
        elem_data.type, elem_data.int_order, material_matrix.dim,
        mesh.elements, mesh.nodes, material_matrix
    )

    K_assembly = assemble_KMF(
        mesh.elements, mesh.nodes,
        [material_matrix, ElasticMaterial(2, E=E_inclusion, ν=ν_inclusion)],
        material_matrix.dim, mesh.type_elem, geometric_data
    )
    K_matrix = K_assembly.K

    bc1 = PeriodicHomogenizationBC([1.0 0.0; 0.0 0.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])
    bc2 = PeriodicHomogenizationBC([0.0 0.0; 0.0 1.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])
    bc3 = PeriodicHomogenizationBC([0.0 1/2; 1/2 0.0], (mesh.master, mesh.slave), mesh.nodes, material_matrix.dim, [true, true])

    F_global = zeros(size(K_matrix, 1))
    U_initial = zeros(size(K_matrix, 1))

    U1 = solve!(K_matrix, F_global, U_initial, [bc1])
    U2 = solve!(K_matrix, F_global, U_initial, [bc2])
    U3 = solve!(K_matrix, F_global, U_initial, [bc3])

    solver_results = (U = (U1, U2, U3),)

    effective_tensor, _ = compute_effective_property(
        [material_matrix, material_inclusion], mesh.elements, mesh.type_elem,
        solver_results, material_matrix.dim, geometric_data
    )

    return effective_tensor.C
end
#&#39;
function compute_effective_C(
    volume_fraction::Float64, n_inclusions::Int, element_order::Int, shape::Symbol, element_type::Symbol,
    node_div_inc::Int, node_div_mat::Int; analysis_type::Symbol, material_props)

    is_tri = startswith(string(element_type), &quot;Tri&quot;)
    int_order = is_tri ? element_order : element_order * 2
    elem_data = ElemData(element_type, int_order, element_order)

    mesh = setup_mesh(
        width=1.0, height=1.0, volume_fraction=volume_fraction, n_inclusions=n_inclusions,
        elem_data=elem_data, node_divisions=(node_div_inc, node_div_mat), shape=shape,
        output_file=&quot;RVE.msh&quot;, voids=false, rdn=true, show_gui=false, to_rotate=true
    )

    if analysis_type == :standard
        return run_standard_elastic_analysis(mesh, elem_data, material_props...)
    elseif analysis_type == :contact
        return run_contact_elastic_analysis(mesh, elem_data, material_props...)
    else
        error(&quot;Unsupported analysis_type: $analysis_type&quot;)
    end
end
#&#39;
function get_mean_effective_C(
    n_realizations::Int, volume_fraction::Float64, n_inclusions::Int, element_order::Int,
    shape::Symbol, element_type::Symbol, node_div_inc::Int, node_div_mat::Int; analysis_type::Symbol, material_props)

    C_tensors = Vector{Matrix{Float64}}(undef, n_realizations)
    for i in 1:n_realizations
        C_tensors[i] = compute_effective_C(
            volume_fraction, n_inclusions, element_order, shape, element_type,
            node_div_inc, node_div_mat; analysis_type=analysis_type, material_props=material_props
        )
    end

    mean_C_tensor = sum(C_tensors) / n_realizations

    stds = [
        std([c[1, 1] for c in C_tensors]),
        std([c[2, 2] for c in C_tensors]),
        std([c[1, 2] for c in C_tensors]),
        std([c[3, 3] for c in C_tensors])
    ]

    return mean_C_tensor, stds
end
#&#39;
function run_sensitivity_analysis(
    n_samples::Int, n_realizations::Int, n_inclusions::Int, element_order::Int, shape::Symbol,
    element_type::Symbol, node_div_inc::Int, node_div_mat::Int;
    min_vf::Float64, max_vf::Float64, analysis_type::Symbol, material_props)

    vf_values = range(min_vf, max_vf, length=n_samples)
    results = Vector{NamedTuple{(:vf, :mean_C, :stds_C), Tuple{Float64, Matrix{Float64}, Vector{Float64}}}}(undef, n_samples)

    println(&quot;Starting Sensitivity Analysis for $(analysis_type)...&quot;)
    for i in 1:n_samples
        vf = vf_values[i]
        mean_C, stds_C = get_mean_effective_C(
            n_realizations, vf, n_inclusions, element_order,
            shape, element_type, node_div_inc, node_div_mat;
            analysis_type=analysis_type, material_props=material_props
        )
        results[i] = (vf=vf, mean_C=mean_C, stds_C=stds_C)
    end

    sort!(results, by = x -&gt; x.vf)

    #&#39;Convert to the format expected by the plotting functions
    vf_sorted = [r.vf for r in results]
    means_sorted = (
        c1111=[r.mean_C[1,1] for r in results],
        c2222=[r.mean_C[2,2] for r in results],
        c1122=[r.mean_C[1,2] for r in results],
        c1212=[r.mean_C[3,3] for r in results]
    )
    stds_sorted = (
        c1111=[r.stds_C[1] for r in results],
        c2222=[r.stds_C[2] for r in results],
        c1122=[r.stds_C[3] for r in results],
        c1212=[r.stds_C[4] for r in results]
    )

    return vf_sorted, means_sorted, stds_sorted
end
#&#39;
function run_convergence_study(
    max_realizations::Int, n_steps::Int, volume_fraction::Float64,
    n_inclusions::Int, element_order::Int, shape::Symbol, element_type::Symbol,
    node_div_inc::Int, node_div_mat::Int; analysis_type::Symbol, material_props)

    all_C_tensors = [compute_effective_C(
        volume_fraction, n_inclusions, element_order, shape, element_type,
        node_div_inc, node_div_mat; analysis_type=analysis_type, material_props=material_props
    ) for _ in 1:max_realizations]

    step_size = floor(Int, max_realizations / n_steps)
    if step_size == 0; step_size = 1; end
    realization_counts = unique(vcat(collect(1:step_size:max_realizations), max_realizations))

    means = [(
        c1111=mean([c[1,1] for c in @view all_C_tensors[1:n]]),
        c2222=mean([c[2,2] for c in @view all_C_tensors[1:n]]),
        c1122=mean([c[1,2] for c in @view all_C_tensors[1:n]]),
        c1212=mean([c[3,3] for c in @view all_C_tensors[1:n]])
    ) for n in realization_counts]

    stds = [(
        c1111= n &gt; 1 ? std([c[1,1] for c in @view all_C_tensors[1:n]]) : 0.0,
        c2222= n &gt; 1 ? std([c[2,2] for c in @view all_C_tensors[1:n]]) : 0.0,
        c1122= n &gt; 1 ? std([c[1,2] for c in @view all_C_tensors[1:n]]) : 0.0,
        c1212= n &gt; 1 ? std([c[3,3] for c in @view all_C_tensors[1:n]]) : 0.0
    ) for n in realization_counts]

    return realization_counts, means, stds
end
#&#39;
function compute_CI(std_devs, n_realizations::Int; confidence::Float64=0.95)
    z_scores = Dict(0.90=&gt;1.645, 0.95=&gt;1.960, 0.99=&gt;2.576)
    z = get(z_scores, confidence, 1.960)
    return z .* std_devs ./ sqrt(n_realizations)
end
#&#39;
function plot_convergence_study(
    realizations, means_std, stds_std, means_contact, stds_contact)

    fig = Figure(size=(1200, 1000), fontsize=18)
    ga = fig[1, 1] = GridLayout()
    gb = fig[2, 1] = GridLayout()
    Label(ga[1, 1:2], &quot;Convergence of Mean Stiffness Components&quot;, fontsize=24, font=:bold, padding=(0,0,20,0))
    Label(gb[1, 1:2], &quot;Convergence of Standard Deviation&quot;, fontsize=24, font=:bold, padding=(0,0,20,0))

    axes_mean = [Axis(ga[2, c], xlabel=&quot;Number of Realizations&quot;, ylabel=&quot;Mean C (GPa)&quot;) for c in 1:2]
    append!(axes_mean, [Axis(ga[3, c], xlabel=&quot;Number of Realizations&quot;, ylabel=&quot;Mean C (GPa)&quot;) for c in 1:2])
    axes_std = [Axis(gb[2, c], xlabel=&quot;Number of Realizations&quot;, ylabel=&quot;Std Dev (GPa)&quot;) for c in 1:2]
    append!(axes_std, [Axis(gb[3, c], xlabel=&quot;Number of Realizations&quot;, ylabel=&quot;Std Dev (GPa)&quot;) for c in 1:2])

    components = [:c1111, :c2222, :c1122, :c1212]
    titles = [&quot;C₁₁₁₁&quot;, &quot;C₂₂₂₂&quot;, &quot;C₁₁₂₂&quot;, &quot;C₁₂₁₂&quot;]

    for i in 1:4
        ax_m, ax_s = axes_mean[i], axes_std[i]
        ax_m.title = titles[i]
        ax_s.title = titles[i]

        lines!(ax_m, realizations, [m[i] for m in means_std], color=:blue, label=&quot;Standard&quot;)
        scatter!(ax_m, realizations, [m[i] for m in means_std], color=:blue)
        lines!(ax_s, realizations, [s[i] for s in stds_std], color=:blue, label=&quot;Standard&quot;)
        scatter!(ax_s, realizations, [s[i] for s in stds_std], color=:blue)

        lines!(ax_m, realizations, [m[i] for m in means_contact], color=:red, label=&quot;Contact&quot;)
        scatter!(ax_m, realizations, [m[i] for m in means_contact], color=:red, marker=:utriangle)
        lines!(ax_s, realizations, [s[i] for s in stds_contact], color=:red, label=&quot;Contact&quot;)
        scatter!(ax_s, realizations, [s[i] for s in stds_contact], color=:red, marker=:utriangle)
    end

    axislegend(axes_mean[1], position=:rt)
    return fig
end
#&#39;
function compute_theoretical_bounds(vf_values, C_matrix)
    #&#39;--- helpers ---------------------------------------------------------
    #&#39;extract effective bulk (κ) and shear (μ) from your 2D C-matrix convention
    #&#39;NOTE: this assumes C_matrix[1,1] == C1111 and C_matrix[3,3] == C1212 (shear)
    κ_m = C_matrix[1,1] - (4.0/3.0)*C_matrix[3,3]
    μ_m = C_matrix[3,3]

    #&#39;Extract ν_matrix for Mori-Tanaka
    ν_matrix = (3*κ_m - 2*μ_m) / (2*(3*κ_m + μ_m))

    #&#39;phase 2 = inclusion / void; user may pass near-zero stiffness or proper C for inclusions
    #&#39;we&#39;ll accept that inclusions are zero-stiffness: κ_i = 0, μ_i = 0 when necessary
    κ_i = 0.0
    μ_i = 0.0

    #&#39;safe reciprocal helper
    safe_inv(x; tol=1e-12) = abs(x) &lt; tol ? sign(x)/tol : 1.0/x

    #&#39;Voigt &amp; Reuss for bulk and shear
    function voigt_reuss(κ1, μ1, κ2, μ2, f2)
        f1 = 1.0 - f2
        κV = f1*κ1 + f2*κ2
        μV = f1*μ1 + f2*μ2
        invκR = (f1/κ1) + (f2/κ2)
        invμR = (f1/μ1) + (f2/μ2)
        κR = invκR == 0.0 ? 0.0 : 1.0 / invκR
        μR = invμR == 0.0 ? 0.0 : 1.0 / invμR
        return κV, μV, κR, μR
    end

    #&#39;robust Hashin-Shtrikman (returns κ_lower, μ_lower, κ_upper, μ_upper)
    function hashin_shtrikman_safe(κ1, μ1, κ2, μ2, f2; tol=1e-12)
        f1 = 1.0 - f2

        Δκ = κ2 - κ1
        termK1 = 3*κ1 + 4*μ1
        denom_a = safe_inv(Δκ; tol=tol) + 3*f1/termK1
        a = κ1 + (abs(denom_a) &lt; tol ? 0.0 : f2 / denom_a)

        Δκ_b = κ1 - κ2
        termK2 = 3*κ2 + 4*μ2
        denom_b = safe_inv(Δκ_b; tol=tol) + 3*f2/termK2
        b = κ2 + (abs(denom_b) &lt; tol ? 0.0 : f1 / denom_b)

        Δμ = μ2 - μ1
        safe_mu = x -&gt; abs(x) &lt; tol ? tol * sign(x) : x

        denom_alpha = safe_inv(Δμ; tol=tol) + 6*f1*(κ1 + 2*μ1) / (5*safe_mu(μ1)*(3*κ1 + 4*μ1))
        α = μ1 + (abs(denom_alpha) &lt; tol ? 0.0 : f2 / denom_alpha)

        denom_beta = safe_inv(-Δμ; tol=tol) + 6*f2*(κ2 + 2*μ2) / (5*safe_mu(μ2)*(3*κ2 + 4*μ2))
        β = μ2 + (abs(denom_beta) &lt; tol ? 0.0 : f1 / denom_beta)

        κ_lower, κ_upper = min(a,b), max(a,b)
        μ_lower, μ_upper = min(α,β), max(α,β)
        return κ_lower, μ_lower, κ_upper, μ_upper
    end

    #&#39;map (κ, μ) -&gt; components used in plotting
    C1111 = (κ, μ) -&gt; κ + (4.0/3.0)*μ
    C1122 = (κ, μ) -&gt; κ - (2.0/3.0)*μ
    C1212 = (κ, μ) -&gt; μ

    #&#39;--- allocate outputs ------------------------------------------------
    vf = collect(vf_values)
    n = length(vf)
    voigt = Dict(k =&gt; zeros(n) for k in (:c1111,:c1122,:c1212))
    reuss = Dict(k =&gt; zeros(n) for k in (:c1111,:c1122,:c1212))
    hs_low = Dict(k =&gt; zeros(n) for k in (:c1111,:c1122,:c1212))
    hs_up  = Dict(k =&gt; zeros(n) for k in (:c1111,:c1122,:c1212))
    mt = Dict(k =&gt; zeros(n) for k in (:c1111,:c1122,:c1212))  #&#39;ADDED: Mori-Tanaka

    #&#39;inclusion moduli (we assume voids; change if you have actual inclusion C)
    κ2 = κ_i
    μ2 = μ_i
    κ1 = κ_m
    μ1 = μ_m

    for (i, f) in enumerate(vf)
        κV, μV, κR, μR = voigt_reuss(κ1, μ1, κ2, μ2, f)
        kll, mll, kuu, muu = hashin_shtrikman_safe(κ1, μ1, κ2, μ2, f)

        #&#39;ADDED: Mori-Tanaka for spherical voids
        κ_mt = κ1 * (1 - f) / (1 + 3*(1-ν_matrix)/(2*(1-2*ν_matrix)) * f)
        μ_mt = μ1 * (1 - f) / (1 + (15*(1-ν_matrix))/(7-5*ν_matrix) * f)

        voigt[:c1111][i] = C1111(κV, μV)
        voigt[:c1122][i] = C1122(κV, μV)
        voigt[:c1212][i] = C1212(κV, μV)

        reuss[:c1111][i] = C1111(κR, μR)
        reuss[:c1122][i] = C1122(κR, μR)
        reuss[:c1212][i] = C1212(κR, μR)

        hs_low[:c1111][i] = C1111(kll, mll)
        hs_low[:c1122][i] = C1122(kll, mll)
        hs_low[:c1212][i] = C1212(kll, mll)

        hs_up[:c1111][i] = C1111(kuu, muu)
        hs_up[:c1122][i] = C1122(kuu, muu)
        hs_up[:c1212][i] = C1212(kuu, muu)

        #&#39;ADDED: Mori-Tanaka values
        mt[:c1111][i] = C1111(κ_mt, μ_mt)
        mt[:c1122][i] = C1122(κ_mt, μ_mt)
        mt[:c1212][i] = C1212(κ_mt, μ_mt)
    end

    return (voigt=voigt, reuss=reuss, hs_lower=hs_low, hs_upper=hs_up, mori_tanaka=mt)  #&#39;ADDED: mori_tanaka
end
#&#39;
function get_matrix_C(E_matrix, ν_matrix; plane_stress=true)
    if plane_stress
        factor = E_matrix / (1 - ν_matrix^2)
        C11 = factor
        C12 = ν_matrix * factor
        C33 = E_matrix / (2*(1 + ν_matrix))
        return [C11 C12 0; C12 C11 0; 0 0 C33]
    else
        factor = E_matrix / ((1 + ν_matrix) * (1 - 2*ν_matrix))
        C11 = factor * (1 - ν_matrix)
        C12 = factor * ν_matrix
        C33 = factor * (1 - 2*ν_matrix) / 2
        return [C11 C12 0; C12 C11 0; 0 0 C33]
    end
end
#&#39;
function plot_sensitivity_results(
    vf_values, means_std, stds_std, means_contact, stds_contact, n_realizations,
    C_matrix)

    bounds = compute_theoretical_bounds(vf_values, C_matrix)

    fig = Figure(size=(1200, 1000), fontsize=18)
    Label(fig[1, 1:2], &quot;Sensitivity Analysis (N = $(n_realizations))&quot;,
          fontsize=24, font=:bold, padding=(0,0,20,0))

    #&#39;Create all axes explicitly
    axes = [
        Axis(fig[2, 1], xlabel=&quot;Volume Fraction (Porosity) ϕ&quot;, ylabel=&quot;Effective Stiffness (GPa)&quot;),
        Axis(fig[2, 2], xlabel=&quot;Volume Fraction (Porosity) ϕ&quot;, ylabel=&quot;Effective Stiffness (GPa)&quot;),
        Axis(fig[3, 1], xlabel=&quot;Volume Fraction (Porosity) ϕ&quot;, ylabel=&quot;Effective Stiffness (GPa)&quot;),
        Axis(fig[3, 2], xlabel=&quot;Volume Fraction (Porosity) ϕ&quot;, ylabel=&quot;Effective Stiffness (GPa)&quot;)
    ]

    components = [:c1111, :c2222, :c1122, :c1212]
    titles = [&quot;C₁₁₁₁&quot;, &quot;C₂₂₂₂&quot;, &quot;C₁₁₂₂&quot;, &quot;C₁₂₁₂&quot;]
    bound_keys = [:c1111, :c1111, :c1122, :c1212]  #&#39;Map plot components to bound components

    for i in 1:4
        ax = axes[i]
        ax.title = titles[i]
        comp_key = components[i]
        bound_key = bound_keys[i]

        ci_std = compute_CI(stds_std[comp_key], n_realizations)
        ci_contact = compute_CI(stds_contact[comp_key], n_realizations)

        #&#39;Plot numerical results
        scatter!(ax, vf_values, means_std[comp_key], marker=:circle, color=:blue)
        errorbars!(ax, vf_values, means_std[comp_key], ci_std, color=:blue)

        scatter!(ax, vf_values, means_contact[comp_key], marker=:utriangle, color=:red)
        errorbars!(ax, vf_values, means_contact[comp_key], ci_contact, color=:red)

        #&#39;Add theoretical bounds
        lines!(ax, vf_values, bounds.voigt[bound_key], color=:green, linestyle=:dash, linewidth=2)
        lines!(ax, vf_values, bounds.hs_upper[bound_key], color=:purple, linestyle=:dash, linewidth=2)
        lines!(ax, vf_values, bounds.hs_lower[bound_key], color=:orange, linestyle=:dash, linewidth=2)
        lines!(ax, vf_values, bounds.mori_tanaka[bound_key], color=:brown, linestyle=:dash, linewidth=2)

        #&#39;For Reuss bound, only show if it&#39;s not too close to zero (for visualization)
        if maximum(bounds.reuss[bound_key]) &gt; 1e-3
            lines!(ax, vf_values, bounds.reuss[bound_key], color=:gray, linestyle=:dash, linewidth=1, alpha=0.7)
        end
    end

    #&#39;Create comprehensive legend
    elements = [
        MarkerElement(marker=:circle, color=:blue, markersize=15),
        LineElement(color=:blue, linestyle=:solid),
        MarkerElement(marker=:utriangle, color=:red, markersize=15),
        LineElement(color=:red, linestyle=:solid),
        LineElement(color=:green, linestyle=:dash, linewidth=2),
        LineElement(color=:purple, linestyle=:dash, linewidth=2),
        LineElement(color=:orange, linestyle=:dash, linewidth=2),
        LineElement(color=:brown, linestyle=:dash, linewidth=2),
        LineElement(color=:gray, linestyle=:dash, linewidth=1, alpha=0.7)
    ]

    labels = [
        &quot;Standard Mean&quot;, &quot;Standard 95% CI&quot;,
        &quot;Contact Mean&quot;, &quot;Contact 95% CI&quot;,
        &quot;Voigt Upper Bound&quot;, &quot;HS Upper Bound&quot;,
        &quot;HS Lower Bound&quot;, &quot;Mori-Tanaka&quot;,
        &quot;Reuss Lower Bound&quot;
    ]

    Legend(fig[4, 1:2], elements, labels,
           orientation=:horizontal, tellwidth=false, tellheight=true,
           framevisible=false, nbanks=3)

    return fig
end
#&#39;
function plot_constitutive_law(vf_values, means_std, means_contact, target_vf::Float64)
    #&#39;Find the index closest to the target volume fraction
    idx = argmin(abs.(vf_values .- target_vf))
    vf_target = vf_values[idx]

    #&#39;Extract the constitutive tensors at the target volume fraction
    C_std = means_std.c1111[idx], means_std.c2222[idx], means_std.c1122[idx], means_std.c1212[idx]
    C_contact = means_contact.c1111[idx], means_contact.c2222[idx], means_contact.c1122[idx], means_contact.c1212[idx]

    #&#39;Convert to matrix format for compatibility
    C_std_matrix = [C_std[1] C_std[3] 0; C_std[3] C_std[2] 0; 0 0 C_std[4]]
    C_contact_matrix = [C_contact[1] C_contact[3] 0; C_contact[3] C_contact[2] 0; 0 0 C_contact[4]]

    fig = Figure(size=(1200, 1000), fontsize=18)
    Label(fig[1, 1:2], &quot;Effective Asymmetric Constitutive Law (ϕ = $(round(vf_target*100, digits=1))% Porosity)&quot;,
          fontsize=24, font=:bold, padding=(0,0,20,0))

    #&#39;Create all axes explicitly
    axes = [
        Axis(fig[2, 1]),
        Axis(fig[2, 2]),
        Axis(fig[3, 1]),
        Axis(fig[3, 2])
    ]

    titles = [
        &quot;σ₁₁ vs ε₁₁ (Uniaxial Loading)&quot;, &quot;σ₂₂ vs ε₂₂ (Uniaxial Loading)&quot;,
        &quot;σ₁₂ vs 2ε₁₂ (Shear Loading)&quot;, &quot;σ₂₂ vs ε₁₁ (Poisson Effect)&quot;
    ]
    xlabels = [&quot;Strain ε₁₁&quot;, &quot;Strain ε₂₂&quot;, &quot;Shear Strain 2ε₁₂&quot;, &quot;Strain ε₁₁&quot;]
    ylabels = [&quot;Stress σ₁₁ (GPa)&quot;, &quot;Stress σ₂₂ (GPa)&quot;, &quot;Stress σ₁₂ (GPa)&quot;, &quot;Stress σ₂₂ (GPa)&quot;]

    strain_range = -0.01:0.0002:0.01

    #&#39;C1111 plot
    stress_std_11 = C_std_matrix[1, 1] .* strain_range
    stress_contact_11 = [ε &gt;= 0 ? C_contact_matrix[1, 1] * ε : C_std_matrix[1, 1] * ε for ε in strain_range]
    lines!(axes[1], strain_range, stress_std_11, label=&quot;Standard&quot;, color=:blue)
    lines!(axes[1], strain_range, stress_contact_11, label=&quot;Contact&quot;, color=:red)

    #&#39;C2222 plot
    stress_std_22 = C_std_matrix[2, 2] .* strain_range
    stress_contact_22 = [ε &gt;= 0 ? C_contact_matrix[2, 2] * ε : C_std_matrix[2, 2] * ε for ε in strain_range]
    lines!(axes[2], strain_range, stress_std_22, color=:blue)
    lines!(axes[2], strain_range, stress_contact_22, color=:red)

    #&#39;C1212 (shear) plot
    stress_std_12 = C_std_matrix[3, 3] .* strain_range
    stress_contact_12 = [ε &gt;= 0 ? C_contact_matrix[3, 3] * ε : C_std_matrix[3, 3] * ε for ε in strain_range]
    lines!(axes[3], strain_range, stress_std_12, color=:blue)
    lines!(axes[3], strain_range, stress_contact_12, color=:red)

    #&#39;C1122 (Poisson) plot
    stress_std_1122 = C_std_matrix[1, 2] .* strain_range
    stress_contact_1122 = [ε &gt;= 0 ? C_contact_matrix[1, 2] * ε : C_std_matrix[1, 2] * ε for ε in strain_range]
    lines!(axes[4], strain_range, stress_std_1122, color=:blue)
    lines!(axes[4], strain_range, stress_contact_1122, color=:red)

    for i in 1:4
        axes[i].title = titles[i]
        axes[i].xlabel = xlabels[i]
        axes[i].ylabel = ylabels[i]
        vlines!(axes[i], [0.0], color=:black, linestyle=:dash)
        hlines!(axes[i], [0.0], color=:black, linestyle=:dash)
    end

    axislegend(axes[1], position=:lt)
    return fig
end
#&#39;
#&#39; ---
#&#39; ##&#39;Analysis Execution
#&#39;
#&#39; We now define the simulation parameters and run the studies.
#&#39;
#&#39;
#&#39; Simulation Parameters
n_realizations = 20
n_samples = 5
max_conv_real = 50
n_conv_steps = 10
#&#39;
#&#39;RVE Parameters
volume_fraction = 0.6 #&#39;60% porosity for final plot
n_inclusions = 10
element_order = 2
shape = :circle
element_type = :Tri6
node_div_inc = 10
node_div_mat = 20
#&#39;
#&#39;Material Properties: Generic Composite with Soft Inclusions
#&#39;Units are in GPa.
E_matrix, ν_matrix = 1.0, 0.3
E_inclusion, ν_inclusion = 1e-6, 0.3
material_props = (E_matrix, ν_matrix, E_inclusion, ν_inclusion)
#&#39;
#&#39;
#&#39; ###&#39;1. Convergence Study
#&#39;
#&#39; The convergence study is performed for a fixed inclusion volume fraction of 60%.
#&#39; We observe how the mean and standard deviation of the effective stiffness
#&#39; components stabilize as the number of geometric realizations increases.
#&#39;
#&#39;
println(&quot;\n Running Convergence Study &quot;)
realization_counts, means_std_conv, stds_std_conv = run_convergence_study(
    max_conv_real, n_conv_steps, volume_fraction, n_inclusions, element_order,
    shape, element_type, node_div_inc, node_div_mat; analysis_type=:standard, material_props=material_props
)
_, means_contact_conv, stds_contact_conv = run_convergence_study(
    max_conv_real, n_conv_steps, volume_fraction, n_inclusions, element_order,
    shape, element_type, node_div_inc, node_div_mat; analysis_type=:contact, material_props=material_props
)
fig_conv = plot_convergence_study(realization_counts, means_std_conv, stds_std_conv, means_contact_conv, stds_contact_conv)
save(&quot;convergence_study.png&quot;, fig_conv)
fig_conv
#&#39;
#&#39;
#&#39; ###&#39;2. Sensitivity Analysis
#&#39;
#&#39; The sensitivity analysis explores the impact of the volume fraction,
#&#39; varying from 10% to 70%, on the effective stiffness components.
#&#39; Each data point is the average of 20 realizations.
#&#39;
#&#39;
println(&quot;\n Running Sensitivity Analysis &quot;)
min_vf, max_vf = 0.1, 0.70
#&#39;
vf_values, means_std, stds_std = run_sensitivity_analysis(
    n_samples, n_realizations, n_inclusions, element_order, shape, element_type,
    node_div_inc, node_div_mat; min_vf=min_vf, max_vf=max_vf, analysis_type=:standard, material_props=material_props
)
_, means_contact, stds_contact = run_sensitivity_analysis(
    n_samples, n_realizations, n_inclusions, element_order, shape, element_type,
    node_div_inc, node_div_mat; min_vf=min_vf, max_vf=max_vf, analysis_type=:contact, material_props=material_props
)
#&#39;
#&#39;Get matrix constitutive tensor for theoretical bounds
C_matrix = get_matrix_C(E_matrix, ν_matrix, plane_stress=true)
#&#39;
#&#39;Plot with theoretical bounds including Mori-Tanaka
fig_sens = plot_sensitivity_results(
    vf_values, means_std, stds_std, means_contact, stds_contact, n_realizations,
    C_matrix
)
save(&quot;sensitivity_analysis.png&quot;, fig_sens)
fig_sens
#&#39;
#&#39;
#&#39; ###&#39;3. Final Comparison and Conclusion
#&#39;
#&#39; Finally, we compare the effective constitutive law for both models
#&#39; at a fixed volume fraction of 60%, reusing the data computed during the sensitivity study.
#&#39;
#&#39;
println(&quot;\n Plotting Constitutive Law using Sensitivity Analysis Results&quot;)
#&#39;
#&#39;Plot constitutive law using the averaged results from sensitivity analysis
target_vf = 0.6  #&#39;60% volume fraction
fig_constitutive = plot_constitutive_law(vf_values, means_std, means_contact, target_vf)
save(&quot;constitutive_law_$(Int(target_vf*100))percent.png&quot;, fig_constitutive)
fig_constitutive
#&#39;
#&#39;
#&#39; The following table summarizes the final results.
#&#39;
#&#39;
#&#39;Also create summary table
println(&quot;\n --- Summary Results for ϕ = $(target_vf*100)% Volume Fraction ---&quot;)
#&#39;
#&#39;Find the index closest to target porosity
idx = argmin(abs.(vf_values .- target_vf))
mean_C_std_at_target = [means_std.c1111[idx], means_std.c2222[idx], means_std.c1122[idx], means_std.c1212[idx]]
mean_C_contact_at_target = [means_contact.c1111[idx], means_contact.c2222[idx], means_contact.c1122[idx], means_contact.c1212[idx]]
#&#39;
@printf &quot;Component | Standard (GPa) | Contact (GPa) | Difference (%%)\n&quot;
@printf &quot;----------|----------------|---------------|----------------\n&quot;
comps = [&quot;C₁₁₁₁&quot;, &quot;C₂₂₂₂&quot;, &quot;C₁₁₂₂&quot;, &quot;C₁₂₁₂&quot;];
for i in 1:4
    std_val = mean_C_std_at_target[i]
    con_val = mean_C_contact_at_target[i]
    diff = (con_val / std_val - 1) * 100
    @printf &quot;%-9s | %14.4f | %13.4f | %13.2f\n&quot; comps[i] std_val con_val diff
end
#&#39;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
 Running Convergence Study

 Running Sensitivity Analysis
Starting Sensitivity Analysis for standard...
Starting Sensitivity Analysis for contact...

 Plotting Constitutive Law using Sensitivity Analysis Results

 --- Summary Results for ϕ = 60.0% Volume Fraction ---
Component | Standard (GPa) | Contact (GPa) | Difference (%)
----------|----------------|---------------|----------------
C₁₁₁₁     |         0.3413 |        0.3424 |          0.33
C₂₂₂₂     |         0.3541 |        0.3477 |         -1.81
C₁₁₂₂     |         0.1169 |        0.1201 |          2.73
C₁₂₁₂     |         0.0698 |        0.0677 |         -3.06</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 7 September 2025 00:35">Sunday 7 September 2025</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
